<?php

namespace Seddkit;

/**
 * A TaintedInputChannel is a collection of tainted object from the same input.
 * PHP Super globals like $_POST, $_GET, $_REQUEST, ... are TaintedSource objects.   
 */
class TaintedArray extends Tainted implements \Iterator, \ArrayAccess, \Countable
{
    private $_iterIndex = 0;
    private $_iterKeys = array();
    
    private $_values = array();
    private $_superg = false;
    
    protected $_deriving = false;
    
    //private $_varname = null;
    
    //private $_locked = false;
    
    public function __clone()
    {
        $this->newHashCode();
        $this->_state = $this->_state->derive();
        $this->_varname = null;
        echo "Clone() is called";
    }
    
    
    /**
     * Check if the key is valid
     * @param unknown $keys_str
     * @return boolean
     */
    private static function checkKey( $key_str)
    {
    	if( preg_match(Seddkit::CONFIG('QUERY_RE'),$key_str) > 0){
    		return true;	
    	}
    	else{
    		return false;
    	}
    }

    
    /**
     * 
     * @param unknown $name_str
     */
    public function __construct($input_array, $varname_str=null, $http_bool=false, $superglobals=false)
    {
        
        $this->newHashCode();
        
        //$this->_locked= true;
        $this->_state = new State();
        $this->_varname = $varname_str;
        $this->_superg = (bool)$superglobals;
        //var_dump($varname_str);
        
        if( isset($input_array)){
            foreach( $input_array as $key=>$val)
            {
            	if($http_bool && self::checkKey($key)){
                    if(is_scalar($val))
                        $this->_values[$key] = new TaintedScalar($val, $this->_varname."[$key]", $http_bool);
                    else
                        $this->_values[$key] = new TaintedArray($val, $this->_varname."[$key]", $http_bool);
            	}
            }
        }
    }
    
    
    /**
    *
    */
    public function newDerivation($method_str, $args_mix=null, $varname_str=null)
    {
        $new = clone $this;
        $new->_state->push($varname_str, $method_str, $args_mix);
        
        // allow access to the value
        $this->_deriving = true;
        
        $new->data = \call_user_func_array($method_str,$args_mix);
        
        // block access to the value
        $this->_deriving = false;
        
        return $new;
    }
    
    public function get($key_str)
    {
        if( isset($this->_values[$key_str])){
            return $this->_values[$key_str];
        }
        else{
            return null;
        }
    }
   

    /* ********** Countable interface ************** */
    public function count(){
        return count($this->_values);
    }
    
    /* ********** Array Access interface ************** */
    
    public function offsetSet($offset, $value)
    {
        if(is_scalar($val))
            $this->_values[$offset] = new TaintedScalar($val,null,$offset,$varname_str);
        elseif(is_array($val))
            $this->_values[$offset] = new TaintedArray($val,null,$offset,$varname_str);
        else
            throw new SeddkitException("",SeddkitException::UNSUPPORTED_VAR_TYPE);
    }
    
    public function offsetExists($offset)
    {
        return isset($this->_values[$offset]);
    }
    
    public function offsetUnset($offset)
    {
        unset($this->_values[$offset]);
    }
    
    public function offsetGet($offset)
    {
        if(isset($this->_values[$offset]))
        {
//            var_dump(!$this->_superg && $this->_values[$offset]->isTainted());
            if(!$this->_superg && $this->_values[$offset]->isTainted())
                throw new DevelopmentSecurityException($this->_values[$offset],'TAINT_CHECKING');
            else
                return $this->_values[$offset];
        }
        else{
            //trigger_error("Undefined index: $offset");
            //  , please use isset() in order to avoid issues.
            throw new SeddkitException("{$this->_varname}[$offset]",SeddkitException::UNKNOW_OFFSET);
            /*
            $this->_values[$offset] = new TaintedInputs();
            $this->_values[$offset]->markAsAutogenerated();

            return $this->_values[$offset];*/
        }
    }
    
    /* ********** Iterator interface ************** */
    
    public function rewind() {
        $this->_iterKeys = array_keys($this->_values);
        $this->_iterIndex = 0;
    }

    public function current() {
        return $this->_values[$this->_iterKeys[$this->_iterIndex]];
    }

    public function key() {
        return $this->_iterKeys[$this->_iterIndex];
    }

    public function next() {
        ++$this->_iterIndex;
    }

    public function valid() {
        return isset($this->_values[$this->_iterKeys[$this->_iterIndex]]);
    }
    
}
?>
